package lk.ijse.gdse71.smartclassroombackend.service.impl;

import jakarta.mail.MessagingException;
import lk.ijse.gdse71.smartclassroombackend.dto.UserDTO;
import lk.ijse.gdse71.smartclassroombackend.entity.Role;
import lk.ijse.gdse71.smartclassroombackend.entity.User;
import lk.ijse.gdse71.smartclassroombackend.exception.AccessDeniedException;
import lk.ijse.gdse71.smartclassroombackend.exception.IllegalArgumentException;
import lk.ijse.gdse71.smartclassroombackend.exception.ResourceNotFoundException;
import lk.ijse.gdse71.smartclassroombackend.repository.UserRepository;
import lk.ijse.gdse71.smartclassroombackend.service.BrevoEmailService;
import lk.ijse.gdse71.smartclassroombackend.service.EmailService;
import lk.ijse.gdse71.smartclassroombackend.service.UserService;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.modelmapper.TypeToken;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.security.SecureRandom;
import java.time.LocalDate;
import java.util.List;
import java.util.Objects;

/**
 * --------------------------------------------
 * Author: Zeenathul Ilma
 * GitHub: https://github.com/Seenathul-Ilma
 * Website: https://zeenathulilma.vercel.app/
 * --------------------------------------------
 * Created: 8/15/2025 7:23 PM
 * Project: AAD-SecondSemester-FinalProject
 * --------------------------------------------
 **/

@Service  // Marks this class as a Spring service component (business logic layer)
@RequiredArgsConstructor // Lombok generates a constructor for all final fields (for dependency injection)
public class UserServiceImpl implements UserService {

    // Example dependency (repository)
    // Spring will inject this automatically via the constructor generated by @RequiredArgsConstructor
    // RequiredArgsConstructor annotation (from Lombok) automatically generates a constructor only for final fields and fields marked with @NonNull
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;
    private final EmailService emailService;
    private final BrevoEmailService brevoEmailService;
    private static final SecureRandom random = new SecureRandom();

    @Override
    public List<UserDTO> getAllStudents() {
        List<User> users = userRepository.findAllByRole(Role.STUDENT);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllTeachers() {
        List<User> users = userRepository.findAllByRole(Role.TEACHER);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllAdmins() {
        List<User> users = userRepository.findAllByRole(Role.ADMIN);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public String generateNextUserId(Role role) {
        String year = String.valueOf(LocalDate.now().getYear());

        String prefix = role.name().substring(0,3) + year;   // STU + 2025

        //User lastTeacher = userRepository.findTopByRoleOrderByUser_idDesc(Role.TEACHER);
        User lastUser = userRepository.findTopByRoleOrderByUserIdDesc(role);

        int nextSequence = 1;

        if(lastUser != null) {
            String lastId = lastUser.getUserId();   // TEA20250015
            nextSequence = Integer.parseInt(lastId.substring(7)) + 1;    // TEA2025 + ...1
        }

        return prefix + String.format("%04d", nextSequence);     // TEA20250001
    }

    @Override
    @Transactional
    public boolean saveUser(UserDTO userDTO, Role role) throws IOException, MessagingException {
        String newId = generateNextUserId(role);

        if(userRepository.existsById(newId)) {
            System.out.println(newId + "User already exist..!");
            return false;
        }

        if (userDTO.getName() == null || userDTO.getAddress() == null || userDTO.getContact() == null || userDTO.getEmail() == null) {
            throw new IllegalArgumentException("Name, Address, Contact No and Email are required!");
        }

        userDTO.setUserId(newId);
        userDTO.setRole(role.name());

        /*String defaultPassword;
        switch (role) {
            case ADMIN -> defaultPassword = "admin1234";
            case TEACHER -> defaultPassword = "teach1234";
            default -> defaultPassword = "abcd1234";
        }*/

        String generatedPassword = generatePassword(12);

        String hashedPassword = BCrypt.hashpw(generatedPassword, BCrypt.gensalt());

        //userDTO.setPassword(generatedPassword);
        userDTO.setPassword(hashedPassword);

        if (BCrypt.checkpw(generatedPassword, hashedPassword)){
            System.out.println("************* Same *************");
            System.out.println("Generated Password: "+ generatedPassword);
            System.out.println("Hashed Password: "+ hashedPassword);
        } else {
            System.out.println("************* Diff *************");
            System.out.println("Generated Password: "+ generatedPassword);
            System.out.println("Hashed Password: "+ hashedPassword);
        }

        User user = modelMapper.map(userDTO, User.class);
        user.setRole(Role.valueOf(userDTO.getRole()));
        userRepository.save(user);

        // Send email asynchronously
        /*emailService.sendUserEmail(userDTO.getEmail(),
                "Welcome to Smart Classroom - Your Password",
                "Hello " + userDTO.getName() + ",\n\n" +
                        "Your account has been created.\n" +
                        "User ID: " + userDTO.getUserId() + "\n" +
                        "Password: " + defaultPassword + "\n\n" +
                        "Please change your password after logging in.");*/

        String emailRole = userDTO.getRole().toLowerCase();
        emailRole = emailRole.substring(0,1).toUpperCase() + emailRole.substring(1);

        String htmlContent = "<html>" +
                "<body style='font-family: Arial, sans-serif; line-height: 1.6;'>" +
                "<h2>Welcome to Smart Classroom..!</h2>" +
                "<p>Hello <strong>" + userDTO.getName() + "</strong>,</p>" +
                "<p>Your account has been created successfully. Here’s your login info:</p>" +
                "<table style='border-collapse: collapse; width: 100%; max-width: 400px;'>" +
                "  <tr style='background-color: #f2f2f2;'>" +
                //"    <th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>User ID</th>" +
                "    <th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>"+ emailRole + " ID</th>" +
                "    <th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>Username</th>" +
                "    <th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>Password</th>" +
                "  </tr>" +
                "  <tr style='background-color: #ffffff;'>" +
                "    <td style='border: 1px solid #ddd; padding: 8px;'>" + userDTO.getUserId() + "</td>" +
                "    <td style='border: 1px solid #ddd; padding: 8px;'>" + userDTO.getEmail() + "</td>" +
                "    <td style='border: 1px solid #ddd; padding: 8px;'>" + generatedPassword + "</td>" +
                "  </tr>" +
                "</table>" +
                "<p>Please <strong>change your password</strong> after logging in.</p>" +
                "<p>Thanks,<br/>Smart Classroom Team</p>" +
                "</body>" +
                "</html>";

        /*emailService.sendUserEmail(
                userDTO.getEmail(),
                "Start Your Journey with Smart Classroom Today",
                htmlContent
        );*/

        brevoEmailService.sendEmail(
                userDTO.getEmail(),
                "Start Your Journey with Smart Classroom Today",
                htmlContent
        );

        return true;
    }

    public String generatePassword(int length) {
        if(length < 8) {
            length = 8;
        }

        String uppercaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String lowercaseLetters = "abcdefghijklmnopqrstuvwxyz";
        String digits = "0123456789";
        String specialChars = "@#$%^&+=";
        String allTypes = uppercaseLetters + lowercaseLetters + digits + specialChars;

        StringBuilder generatedPassword = new StringBuilder();
        generatedPassword.append(uppercaseLetters.charAt(random.nextInt(uppercaseLetters.length())));
        generatedPassword.append(lowercaseLetters.charAt(random.nextInt(lowercaseLetters.length())));
        generatedPassword.append(digits.charAt(random.nextInt(digits.length())));
        generatedPassword.append(specialChars.charAt(random.nextInt(specialChars.length())));

        for (int i = 4; i < length; i++){
            generatedPassword.append(allTypes.charAt(random.nextInt(allTypes.length())));
        }

        char[] passwordArray = generatedPassword.toString().toCharArray();
        for (int x=0; x<passwordArray.length; x++){
            int y = random.nextInt(passwordArray.length);
            char temp = passwordArray[x];
            passwordArray[x] = passwordArray[y];
            passwordArray[y] = temp;
        }

        return String.valueOf(generatedPassword);

    }

    @Override
    public UserDTO getUserByEmail(String email) {
        User existingUser = userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found..!"));
        System.out.println(email);
        System.out.println(existingUser.getUserId());
        System.out.println(existingUser.getEmail());
        System.out.println(existingUser.getPassword());

        return modelMapper.map(existingUser, UserDTO.class);
    }

    @Override
    @Transactional
    public boolean updateUser(UserDTO userDTO, Role role) {
        // Check if user exists
        User existingUser = userRepository.findById(userDTO.getUserId())
                .orElseThrow(() -> new ResourceNotFoundException("User not found..!"));

        userDTO.setRole(existingUser.getRole().name());

        String newPassword = userDTO.getPassword();
        String finalPassword;

        if (newPassword == null || newPassword.isBlank()) {
            // No new password provided keep existing hash
            finalPassword = existingUser.getPassword();
            System.out.println("Keeping existing password for user: " + userDTO.getUserId());
        } else if (BCrypt.checkpw(newPassword, existingUser.getPassword())) {
            // New password matches the existing password keep existing hash
            finalPassword = existingUser.getPassword();
            System.out.println("New password same as old, not updating for user: " + userDTO.getUserId());
        } else {
            // New password is different hash it
            finalPassword = BCrypt.hashpw(newPassword, BCrypt.gensalt());
            System.out.println("Updating password for user: " + userDTO.getUserId());
            System.out.println("New hashed password: " + finalPassword);
        }

        // Update DTO
        userDTO.setPassword(finalPassword);

        // Map DTO -> Entity
        User userToUpdate = modelMapper.map(userDTO, User.class);

        // Always set role from existing user (ignore request role)
        userToUpdate.setRole(existingUser.getRole());

        // Save
        userRepository.save(userToUpdate);
        return true;
    }


    @Override
    @Transactional
    public boolean deleteUser(String id) {
        // Fetch the user by ID
        User userToDelete = userRepository.findById(id).orElse(null);

        if (userToDelete == null) {
            return false; // user not found
        }

        // Delete the user
        userRepository.delete(userToDelete);
        return true; // deletion successful
    }

    @Override
    public Page<UserDTO> getUsersByPaginated(int page, int size, Role role) {
        // Pass role first, then pageable
        Page<User> userPage = userRepository.findAllByRole(role, PageRequest.of(page, size));

        // Map each User entity to UserDTO
        return userPage.map(user -> modelMapper.map(user, UserDTO.class));
    }

}

// @Service
//   -  Marks this class as a Spring service component (business logic layer)
//   -  Spring will:
//          Automatically detect it during component scanning (@Component stereotype).
//          Register it as a Spring bean in the application context.
//          Allow dependency injection into controllers or other services.
//   -  Why use it:
//          Differentiates service layer classes from repositories (@Repository) and controllers (@Controller/@RestController).
//          Semantically makes it clear: “This class contains business logic.”


// @RequiredArgsConstructor
//   - Lombok generates a constructor for all final fields (for dependency injection)
//   - Why it’s useful in Spring:
//          Spring can inject dependencies via constructor injection automatically.
//          Cleaner than writing constructors manually.
//          Encourages immutability because final fields cannot be reassigned.
//          No manual constructor needed because @RequiredArgsConstructor generates it.
//          Spring injects UserRepository automatically.