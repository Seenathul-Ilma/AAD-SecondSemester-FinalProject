package lk.ijse.gdse71.smartclassroombackend.service.impl;

import lk.ijse.gdse71.smartclassroombackend.dto.UserDTO;
import lk.ijse.gdse71.smartclassroombackend.entity.Role;
import lk.ijse.gdse71.smartclassroombackend.entity.User;
import lk.ijse.gdse71.smartclassroombackend.exception.IllegalArgumentException;
import lk.ijse.gdse71.smartclassroombackend.repository.UserRepository;
import lk.ijse.gdse71.smartclassroombackend.service.UserService;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.modelmapper.TypeToken;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * --------------------------------------------
 * Author: Zeenathul Ilma
 * GitHub: https://github.com/Seenathul-Ilma
 * Website: https://zeenathulilma.vercel.app/
 * --------------------------------------------
 * Created: 8/15/2025 7:23 PM
 * Project: AAD-SecondSemester-FinalProject
 * --------------------------------------------
 **/

@Service  // Marks this class as a Spring service component (business logic layer)
@RequiredArgsConstructor // Lombok generates a constructor for all final fields (for dependency injection)
public class UserServiceImpl implements UserService {

    // Example dependency (repository)
    // Spring will inject this automatically via the constructor generated by @RequiredArgsConstructor
    // RequiredArgsConstructor annotation (from Lombok) automatically generates a constructor only for final fields and fields marked with @NonNull
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;

    @Override
    public List<UserDTO> getAllStudents() {
        List<User> users = userRepository.findAllByRole(Role.STUDENT);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllTeachers() {
        List<User> users = userRepository.findAllByRole(Role.TEACHER);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllAdmins() {
        List<User> users = userRepository.findAllByRole(Role.ADMIN);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public String generateNextUserId(Role role) {
        String year = String.valueOf(LocalDate.now().getYear());

        String prefix = role.name().substring(0,3) + year;   // STU + 2025

        //User lastTeacher = userRepository.findTopByRoleOrderByUser_idDesc(Role.TEACHER);
        User lastUser = userRepository.findTopByRoleOrderByUserIdDesc(role);

        int nextSequence = 1;

        if(lastUser != null) {
            String lastId = lastUser.getUserId();   // TEA20250015
            nextSequence = Integer.parseInt(lastId.substring(7)) + 1;    // TEA2025 + ...1
        }

        return prefix + String.format("%04d", nextSequence);     // TEA20250001
    }

    @Override
    public boolean saveUser(UserDTO userDTO, Role role) {
        String newId = generateNextUserId(role);

        if(userRepository.existsById(newId)) {
            System.out.println(newId + "User already exist..!");
            return false;
        }

        userDTO.setUserId(newId);
        userDTO.setRole(role.name());

        String defaultPassword;
        switch (role) {
            case ADMIN -> defaultPassword = "admin1234";
            case TEACHER -> defaultPassword = "teach1234";
            default -> defaultPassword = "abcd1234";
        }

        userDTO.setPassword(defaultPassword);

        if (userDTO.getName() == null || userDTO.getAddress() == null || userDTO.getContact() == null || userDTO.getEmail() == null) {
            throw new IllegalArgumentException("Name, Address, Contact No and Email are required!");
        }

        User user = modelMapper.map(userDTO, User.class);
        user.setRole(Role.valueOf(userDTO.getRole()));
        userRepository.save(user);
        return true;
    }

    @Override
    public boolean updateUser(UserDTO userDTO, Role role) {
        // Check if user exists
        User existingUser = userRepository.findById(userDTO.getUserId()).orElse(null);
        if (existingUser == null) {
            return false; // userId not found
        }

        // Check if role matches
        if (!existingUser.getRole().equals(role)) {
            return false; // role mismatch
        }

        // Map DTO → Entity and save
        User userToUpdate = modelMapper.map(userDTO, User.class);
        userToUpdate.setRole(role); // ensure role is correct
        userRepository.save(userToUpdate);
        return true;
    }

    @Override
    public boolean deleteUser(String id) {
        // Fetch the user by ID
        User userToDelete = userRepository.findById(id).orElse(null);

        if (userToDelete == null) {
            return false; // user not found
        }

        // Delete the user
        userRepository.delete(userToDelete);
        return true; // deletion successful
    }

    @Override
    public Page<UserDTO> getUsersByPaginated(int page, int size, Role role) {
        // Pass role first, then pageable
        Page<User> userPage = userRepository.findAllByRole(role, PageRequest.of(page, size));

        // Map each User entity to UserDTO
        return userPage.map(user -> modelMapper.map(user, UserDTO.class));
    }

}

// @Service
//   -  Marks this class as a Spring service component (business logic layer)
//   -  Spring will:
//          Automatically detect it during component scanning (@Component stereotype).
//          Register it as a Spring bean in the application context.
//          Allow dependency injection into controllers or other services.
//   -  Why use it:
//          Differentiates service layer classes from repositories (@Repository) and controllers (@Controller/@RestController).
//          Semantically makes it clear: “This class contains business logic.”


// @RequiredArgsConstructor
//   - Lombok generates a constructor for all final fields (for dependency injection)
//   - Why it’s useful in Spring:
//          Spring can inject dependencies via constructor injection automatically.
//          Cleaner than writing constructors manually.
//          Encourages immutability because final fields cannot be reassigned.
//          No manual constructor needed because @RequiredArgsConstructor generates it.
//          Spring injects UserRepository automatically.