package lk.ijse.gdse71.smartclassroombackend.service.impl;

import lk.ijse.gdse71.smartclassroombackend.dto.UserDTO;
import lk.ijse.gdse71.smartclassroombackend.entity.Role;
import lk.ijse.gdse71.smartclassroombackend.entity.User;
import lk.ijse.gdse71.smartclassroombackend.repository.UserRepository;
import lk.ijse.gdse71.smartclassroombackend.service.UserService;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.modelmapper.TypeToken;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

/**
 * --------------------------------------------
 * Author: Zeenathul Ilma
 * GitHub: https://github.com/Seenathul-Ilma
 * Website: https://zeenathulilma.vercel.app/
 * --------------------------------------------
 * Created: 8/15/2025 7:23 PM
 * Project: AAD-SecondSemester-FinalProject
 * --------------------------------------------
 **/

@Service  // Marks this class as a Spring service component (business logic layer)
@RequiredArgsConstructor // Lombok generates a constructor for all final fields (for dependency injection)
public class UserServiceImpl implements UserService {

    // Example dependency (repository)
    // Spring will inject this automatically via the constructor generated by @RequiredArgsConstructor
    // RequiredArgsConstructor annotation (from Lombok) automatically generates a constructor only for final fields and fields marked with @NonNull
    private final UserRepository userRepository;

    private final ModelMapper modelMapper;

    @Override
    public List<UserDTO> getAllStudents() {
        List<User> users = userRepository.findAllByRole(Role.STUDENT);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllTeachers() {
        List<User> users = userRepository.findAllByRole(Role.TEACHER);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public List<UserDTO> getAllAdmins() {
        List<User> users = userRepository.findAllByRole(Role.ADMIN);
        return modelMapper.map(users, new TypeToken<List<UserDTO>>(){}.getType());
    }

    @Override
    public String generateNextStudentId(){
        String year = String.valueOf(LocalDate.now().getYear());
        String prefix = "STU" + year;   // STU + 2025

        User lastStudent = userRepository.findTopByRoleOrderByUserIdDesc(Role.STUDENT);

        int nextSequence = 1;

        if(lastStudent != null) {
            String lastId = lastStudent.getUserId();   // STU20250015
            nextSequence = Integer.parseInt(lastId.substring(7)) + 1;    // STU2025 + ...1
        }

        return prefix + String.format("%04d", nextSequence);     // STU20250001
    }

    @Override
    public String generateNextTeacherId() {
        String year = String.valueOf(LocalDate.now().getYear());
        String prefix = "TEA" + year;   // STU + 2025

        //User lastTeacher = userRepository.findTopByRoleOrderByUser_idDesc(Role.TEACHER);
        User lastTeacher = userRepository.findTopByRoleOrderByUserIdDesc(Role.TEACHER);

        int nextSequence = 1;

        if(lastTeacher != null) {
            String lastId = lastTeacher.getUserId();   // TEA20250015
            nextSequence = Integer.parseInt(lastId.substring(7)) + 1;    // TEA2025 + ...1
        }

        return prefix + String.format("%04d", nextSequence);     // TEA20250001
    }

    @Override
    public boolean saveUser(UserDTO userDTO) {
        if (userRepository.existsById(userDTO.getUserId())) {
            return false; // if user id already exists
        }
        User savedUser = userRepository.save(modelMapper.map(userDTO, User.class));
        return savedUser != null && savedUser.getUserId() != null;
    }
}

// @Service
//   -  Marks this class as a Spring service component (business logic layer)
//   -  Spring will:
//          Automatically detect it during component scanning (@Component stereotype).
//          Register it as a Spring bean in the application context.
//          Allow dependency injection into controllers or other services.
//   -  Why use it:
//          Differentiates service layer classes from repositories (@Repository) and controllers (@Controller/@RestController).
//          Semantically makes it clear: “This class contains business logic.”


// @RequiredArgsConstructor
//   - Lombok generates a constructor for all final fields (for dependency injection)
//   - Why it’s useful in Spring:
//          Spring can inject dependencies via constructor injection automatically.
//          Cleaner than writing constructors manually.
//          Encourages immutability because final fields cannot be reassigned.
//          No manual constructor needed because @RequiredArgsConstructor generates it.
//          Spring injects UserRepository automatically.